import asyncio
import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List
from loguru import logger

from app.core.scanner import scan_target_async, cleanup_old_reports
from app.services.real_security_apis import real_security_apis

class PentestingService:
    """Servicio completo de pentesting con Wapiti, Nikto y APIs reales"""
    
    def __init__(self):
        self.results_dir = Path("results")
        self.results_dir.mkdir(exist_ok=True)
        
    async def comprehensive_pentest(self, target_url: str) -> Dict:
        """Ejecutar pentesting completo con todas las herramientas"""
        logger.info(f"Iniciando pentesting completo para: {target_url}")
        
        # Limpiar reportes anteriores
        cleanup_old_reports()
        
        # Generar ID único para esta sesión
        session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Ejecutar todos los análisis en paralelo
        results = await asyncio.gather(
            # Escaneos con herramientas locales
            self._run_wapiti_nikto_scan(target_url),
            # APIs de seguridad
            real_security_apis.comprehensive_security_audit(target_url),
            return_exceptions=True
        )
        
        # Compilar resultados completos
        pentest_report = {
            'session_id': session_id,
            'target_url': target_url,
            'timestamp': datetime.now().isoformat(),
            'scan_tools': results[0] if not isinstance(results[0], Exception) else {'error': str(results[0])},
            'security_apis': results[1] if not isinstance(results[1], Exception) else {'error': str(results[1])},
            'executive_summary': self._generate_executive_summary(results),
            'recommendations': self._generate_recommendations(results)
        }
        
        # Guardar reporte completo
        report_file = self.results_dir / f"pentest_report_{session_id}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(pentest_report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Pentesting completo finalizado. Reporte guardado en: {report_file}")
        return pentest_report
    
    async def _run_wapiti_nikto_scan(self, target_url: str) -> Dict:
        """Ejecutar Wapiti y Nikto en paralelo"""
        try:
            # Ejecutar escaneos asíncronos
            scan_results = await scan_target_async(target_url)
            
            # Procesar resultados de cada herramienta
            processed_results = {}
            
            for tool, result in scan_results.items():
                if tool == 'wapiti':
                    processed_results['wapiti'] = await self._process_wapiti_results(result)
                elif tool == 'nikto':
                    processed_results['nikto'] = await self._process_nikto_results(result)
            
            return processed_results
            
        except Exception as e:
            logger.error(f"Error en escaneo Wapiti/Nikto: {e}")
            return {'error': str(e)}
    
    async def _process_wapiti_results(self, wapiti_result: Dict) -> Dict:
        """Procesar resultados de Wapiti"""
        try:
            # Si Wapiti generó un archivo JSON, leerlo
            if wapiti_result.get('output_file') and os.path.exists(wapiti_result['output_file']):
                with open(wapiti_result['output_file'], 'r', encoding='utf-8') as f:
                    wapiti_data = json.load(f)
                
                # Extraer vulnerabilidades
                vulnerabilities = wapiti_data.get('vulnerabilities', {})
                
                # Contar por severidad
                severity_count = {'high': 0, 'medium': 0, 'low': 0}
                total_vulns = 0
                
                for category, vulns in vulnerabilities.items():
                    if isinstance(vulns, list):
                        for vuln in vulns:
                            total_vulns += 1
                            level = vuln.get('level', 1)
                            if level == 3:
                                severity_count['high'] += 1
                            elif level == 2:
                                severity_count['medium'] += 1
                            else:
                                severity_count['low'] += 1
                
                return {
                    'status': 'completed',
                    'vulnerabilities': vulnerabilities,
                    'statistics': {
                        'total_vulnerabilities': total_vulns,
                        'severity_breakdown': severity_count,
                        'categories_found': list(vulnerabilities.keys())
                    },
                    'raw_output': wapiti_result.get('stdout', ''),
                    'target_info': wapiti_data.get('infos', {})
                }
            else:
                return {
                    'status': 'error',
                    'error': 'No se pudo leer el archivo de resultados de Wapiti',
                    'raw_output': wapiti_result.get('stdout', ''),
                    'stderr': wapiti_result.get('stderr', '')
                }
                
        except Exception as e:
            logger.error(f"Error procesando resultados Wapiti: {e}")
            return {'status': 'error', 'error': str(e)}
    
    async def _process_nikto_results(self, nikto_result: Dict) -> Dict:
        """Procesar resultados de Nikto"""
        try:
            findings = []
            severity_count = {'high': 0, 'medium': 0, 'low': 0}
            
            # Procesar stdout de Nikto
            output_lines = nikto_result.get('stdout', '').split('\n')
            
            for line in output_lines:
                line = line.strip()
                if line and '+' in line and 'OSVDB' in line:
                    # Parsear línea de vulnerabilidad de Nikto
                    finding = self._parse_nikto_line(line)
                    if finding:
                        findings.append(finding)
                        # Clasificar severidad (básica)
                        if any(keyword in line.lower() for keyword in ['critical', 'dangerous', 'exploit']):
                            severity_count['high'] += 1
                        elif any(keyword in line.lower() for keyword in ['warning', 'medium', 'potential']):
                            severity_count['medium'] += 1
                        else:
                            severity_count['low'] += 1
            
            return {
                'status': 'completed',
                'findings': findings,
                'statistics': {
                    'total_findings': len(findings),
                    'severity_breakdown': severity_count
                },
                'raw_output': nikto_result.get('stdout', ''),
                'stderr': nikto_result.get('stderr', '')
            }
            
        except Exception as e:
            logger.error(f"Error procesando resultados Nikto: {e}")
            return {'status': 'error', 'error': str(e)}
    
    def _parse_nikto_line(self, line: str) -> Dict:
        """Parsear línea de resultado de Nikto"""
        try:
            # Formato típico: + /path: Description - Reference
            if line.startswith('+'):
                parts = line[1:].split(': ', 1)
                if len(parts) == 2:
                    path = parts[0].strip()
                    description = parts[1].strip()
                    
                    return {
                        'path': path,
                        'description': description,
                        'type': 'nikto_finding',
                        'timestamp': datetime.now().isoformat()
                    }
        except Exception:
            pass
        return None
    
    def _generate_executive_summary(self, results: List) -> Dict:
        """Generar resumen ejecutivo del pentesting"""
        try:
            scan_tools = results[0] if not isinstance(results[0], Exception) else {}
            security_apis = results[1] if not isinstance(results[1], Exception) else {}
            
            # Contar vulnerabilidades totales
            total_vulns = 0
            critical_issues = 0
            
            # Wapiti
            if 'wapiti' in scan_tools:
                wapiti_stats = scan_tools['wapiti'].get('statistics', {})
                total_vulns += wapiti_stats.get('total_vulnerabilities', 0)
                critical_issues += wapiti_stats.get('severity_breakdown', {}).get('high', 0)
            
            # Nikto
            if 'nikto' in scan_tools:
                nikto_stats = scan_tools['nikto'].get('statistics', {})
                total_vulns += nikto_stats.get('total_findings', 0)
                critical_issues += nikto_stats.get('severity_breakdown', {}).get('high', 0)
            
            # APIs de seguridad
            risk_score = 0
            if 'risk_assessment' in security_apis:
                risk_score = security_apis['risk_assessment'].get('score', 0)
            
            # Determinar nivel de riesgo general
            if critical_issues > 5 or risk_score > 80:
                overall_risk = 'CRITICAL'
            elif critical_issues > 2 or risk_score > 60:
                overall_risk = 'HIGH'
            elif critical_issues > 0 or risk_score > 40:
                overall_risk = 'MEDIUM'
            else:
                overall_risk = 'LOW'
            
            return {
                'overall_risk_level': overall_risk,
                'total_vulnerabilities_found': total_vulns,
                'critical_issues': critical_issues,
                'risk_score': risk_score,
                'tools_used': ['Wapiti', 'Nikto', 'VirusTotal', 'Shodan', 'AbuseIPDB', 'Nmap'],
                'scan_duration': 'Aproximadamente 5-10 minutos',
                'key_findings': self._extract_key_findings(scan_tools, security_apis)
            }
            
        except Exception as e:
            logger.error(f"Error generando resumen ejecutivo: {e}")
            return {'error': str(e)}
    
    def _extract_key_findings(self, scan_tools: Dict, security_apis: Dict) -> List[str]:
        """Extraer hallazgos clave"""
        findings = []
        
        try:
            # VirusTotal
            if 'virustotal_url' in security_apis:
                vt_url = security_apis['virustotal_url']
                if vt_url.get('positives', 0) > 0:
                    findings.append(f"VirusTotal detectó {vt_url['positives']} motores como maliciosos")
            
            # Wapiti
            if 'wapiti' in scan_tools and scan_tools['wapiti'].get('statistics', {}).get('total_vulnerabilities', 0) > 0:
                findings.append(f"Wapiti encontró {scan_tools['wapiti']['statistics']['total_vulnerabilities']} vulnerabilidades")
            
            # Nikto
            if 'nikto' in scan_tools and scan_tools['nikto'].get('statistics', {}).get('total_findings', 0) > 0:
                findings.append(f"Nikto identificó {scan_tools['nikto']['statistics']['total_findings']} problemas potenciales")
            
            # SSL
            if 'ssl_certificate' in security_apis:
                ssl_cert = security_apis['ssl_certificate']
                if ssl_cert.get('is_expired'):
                    findings.append("Certificado SSL expirado")
            
            # Puertos abiertos
            if 'port_scan' in security_apis:
                ports = security_apis['port_scan'].get('ports', [])
                if len(ports) > 5:
                    findings.append(f"{len(ports)} puertos abiertos detectados")
            
        except Exception as e:
            logger.error(f"Error extrayendo hallazgos clave: {e}")
        
        return findings if findings else ['No se encontraron problemas críticos']
    
    def _generate_recommendations(self, results: List) -> List[str]:
        """Generar recomendaciones de seguridad"""
        recommendations = []
        
        try:
            scan_tools = results[0] if not isinstance(results[0], Exception) else {}
            security_apis = results[1] if not isinstance(results[1], Exception) else {}
            
            # Recomendaciones basadas en Wapiti
            if 'wapiti' in scan_tools:
                wapiti_vulns = scan_tools['wapiti'].get('vulnerabilities', {})
                if 'SQL Injection' in wapiti_vulns:
                    recommendations.append("Implementar validación y sanitización de entrada para prevenir inyección SQL")
                if 'Cross Site Scripting' in wapiti_vulns:
                    recommendations.append("Implementar filtrado y codificación de salida para prevenir XSS")
                if 'File Handling' in wapiti_vulns:
                    recommendations.append("Revisar manejo de archivos y validar rutas para prevenir directory traversal")
            
            # Recomendaciones basadas en SSL
            if 'ssl_certificate' in security_apis:
                ssl_cert = security_apis['ssl_certificate']
                if ssl_cert.get('is_expired'):
                    recommendations.append("Renovar certificado SSL expirado inmediatamente")
                if ssl_cert.get('error'):
                    recommendations.append("Configurar certificado SSL válido")
            
            # Recomendaciones basadas en headers de seguridad
            if 'security_headers' in security_apis:
                sec_headers = security_apis['security_headers']
                if not sec_headers.get('strict_transport_security'):
                    recommendations.append("Implementar header HSTS (Strict-Transport-Security)")
                if not sec_headers.get('content_security_policy'):
                    recommendations.append("Configurar Content Security Policy (CSP)")
                if not sec_headers.get('x_frame_options'):
                    recommendations.append("Añadir header X-Frame-Options para prevenir clickjacking")
            
            # Recomendaciones basadas en puertos
            if 'port_scan' in security_apis:
                ports = security_apis['port_scan'].get('ports', [])
                if len(ports) > 10:
                    recommendations.append("Revisar y cerrar puertos innecesarios expuestos")
            
            # Recomendaciones generales
            recommendations.extend([
                "Realizar auditorías de seguridad regulares",
                "Mantener software y dependencias actualizadas",
                "Implementar monitoreo de seguridad continuo",
                "Capacitar al equipo en mejores prácticas de seguridad"
            ])
            
        except Exception as e:
            logger.error(f"Error generando recomendaciones: {e}")
        
        return recommendations
    
    def get_latest_report(self) -> Dict:
        """Obtener el último reporte de pentesting"""
        try:
            report_files = list(self.results_dir.glob("pentest_report_*.json"))
            if not report_files:
                return {'error': 'No hay reportes disponibles'}
            
            # Obtener el más reciente
            latest_file = max(report_files, key=lambda f: f.stat().st_mtime)
            
            with open(latest_file, 'r', encoding='utf-8') as f:
                return json.load(f)
                
        except Exception as e:
            logger.error(f"Error obteniendo último reporte: {e}")
            return {'error': str(e)}

# Instancia global
pentesting_service = PentestingService()

